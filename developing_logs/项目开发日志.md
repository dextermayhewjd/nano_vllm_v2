#

## 1) 初始化项目骨架（uv init）

```bash
uv init
uv add torch triton transformers cmake ninja 
```

## 2） 项目入口

nanovllm/__init__.py
```python
from .llm import LLM
from .sampling_params import SamplingParams

__all__ = ["LLM", "SamplingParams"]
```

因为我们这一步（T0-1）的验收目标非常窄：“包能 import，不炸”。nanovllm/__init__.py 就是这个包的“门面”，它决定了用户写：

```python
from nanovllm import LLM, SamplingParams
```
能不能工作。你看到的写法是在做三件事：

### 2.1) 把“对外 API”固定下来（门面层）

```python
from .llm import LLM
from .sampling_params import SamplingParams
```
意思是：

包内部真正的实现可能散落在 llm.py、engine/、layers/ 等很多文件里
但对外只承诺两个最常用入口：LLM 和 SamplingParams
这样以后你改内部结构（比如把 LLM 拆成 LLMEngine + Runner + Scheduler），外部用法不需要改。

### 2.2) __all__ 是在“声明公开符号”

```python
__all__ = ["LLM", "SamplingParams"]
```

它的作用是：

明确告诉读代码的人：这个包公开/稳定的接口是什么

from nanovllm import * 时只导出这些（虽然我们一般不推荐 *，但这是标准做法）

这一步对“工程习惯”和“可维护性”很重要：你一眼就知道哪些是 API，哪些是内部细节。



## 3 初始化 LLM  和 Sampling_param 这两个class